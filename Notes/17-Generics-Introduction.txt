ğŸš€ What Are Generics in C#?
----------------------------

Generics in C# allow you to create reusable, type-safe code without specifying the exact data type in advance. Instead of writing separate code for different data types, generics let you use placeholders (like <T>) that work with any type.

Think of generics like a template that adapts to different data types!

ğŸ” Why Do We Need Generics?
----------------------------

Before generics, we used object type to handle different data types. But this led to type casting issues, performance problems, and runtime errors. Generics solve these problems by enforcing type safety at compile time and improving performance.

ğŸš« Without Generics (Using Object Type, Bad Practice ğŸ˜µ)

class Box
{
    private object value;  // Can store any type (BAD!)

    public void SetValue(object val)
    {
        value = val;
    }

    public object GetValue()
    {
        return value;
    }
}

// Usage
Box box = new Box();
box.SetValue(10);  // Storing an int
int num = (int)box.GetValue();  // Needs casting! ğŸ˜£


âš  Problems?

Casting needed ((int)box.GetValue()) â€“ This can cause runtime errors!

Performance issue (Boxing & Unboxing for value types).

âœ… Using Generics (Good Practice ğŸ˜)

class Box<T>  // T is a placeholder for a type
{
    private T value;

    public void SetValue(T val)
    {
        value = val;
    }

    public T GetValue()
    {
        return value;
    }
}

// Usage
Box<int> intBox = new Box<int>();  
intBox.SetValue(10);
int num = intBox.GetValue();  // No casting needed! ğŸ‰

ğŸ”¥ Benefits?

âœ” Type-safe (No accidental type mismatches)
âœ” No need for type casting
âœ” Better performance (No boxing/unboxing)


ğŸ“Œ Key Places Where Generics Are Used

1ï¸âƒ£ Generic Classes
----------------

Used to create classes that work with any data type.

class Storage<T>
{
    private T item;
    public void Store(T item) => this.item = item;
    public T Retrieve() => item;
}

// Usage
Storage<string> strStorage = new Storage<string>();
strStorage.Store("Hello");
Console.WriteLine(strStorage.Retrieve());  // Output: Hello


2ï¸âƒ£ Generic Methods
-------------------

Used to write methods that work with any type.

class Utility
{
    public static void Print<T>(T value)
    {
        Console.WriteLine(value);
    }
}

// Usage
Utility.Print(100);    // Works with int
Utility.Print("Hello"); // Works with string
Utility.Print(3.14);   // Works with double

3ï¸âƒ£ Generic Interfaces
------------------

Interfaces can also be generic to enforce type safety.

interface IRepository<T>
{
    void Add(T item);
}

class UserRepository : IRepository<string>
{
    public void Add(string user)
    {
        Console.WriteLine($"User {user} added!");
    }
}


4ï¸âƒ£ Generic Collections (Most Common Use Case)
----------------------------------------

Without Generics âŒ							With Generics âœ…

ArrayList (stores object type)		List<T> (stores a specific type)
Hashtable (stores object)		Dictionary<TKey, TValue>
Stack (stores object)			Stack<T>
Queue (stores object)			Queue<T>

Most C# collections are generic!

List<int> numbers = new List<int>();  // Generic List<T>
numbers.Add(1);
numbers.Add(2);
Console.WriteLine(numbers[0]);  // Output: 1

5ï¸âƒ£ Generic Constraints (where T : ...)
---------------------------------
Sometimes, we want to restrict what type T can be.

class Repository<T> where T : class  // T must be a class
{
    public void Save(T entity) => Console.WriteLine("Saved!");
}


ğŸ” Summary

Feature			Without Generics ğŸ˜–		With Generics ğŸ˜

Type Safety		No (Needs casting)		Yes (No casting)
Performance		Slower (Boxing/Unboxing)	Faster
Code Reusability	No (Redundant code)		Yes (Reusable templates)
Compile-Time Errors	More runtime errors		Catches errors at compile-time


ğŸ¯ Key Takeaways

âœ” Generics allow you to write reusable, type-safe, and efficient code
âœ” No need for type casting â†’ Avoids runtime errors 
âœ” Faster performance â†’ No unnecessary memory operations
âœ” Used in Generic Classes, Methods, Interfaces, and Collections












